# Docker镜像优化

## 镜像优化技巧

### 基础优化方法
- **小基础镜像**: ubuntu(72MB) → alpine(5MB) → scratch(0MB)
- **多阶段构建**: 编译阶段用大镜像，运行阶段用小镜像，减少75%体积
- **合并RUN**: 一个RUN命令减少镜像层数zz
- **清理文件**: 删除编译工具和临时文件
- **dockerignore**: 排除不必要文件

### 容器日志管理
> 容器日志打满会导致节点磁盘耗尽，影响服务稳定。我们一般通过配置 Docker 的日志轮转（如 max-size、max-file），限制单个日志文件大小和数量，从根本上防止日志打满。生产环境还会用 ELK、Loki 等集中式日志方案，把日志收集到外部系统，节点本地只保留短期日志。应急时可以手动清理大日志文件，但更重要的是提前做好日志管理和监控。

容器日志存储到哪里，怎么设置容器日志定时清除
容器日志默认存储到宿主机上，设置定时清除可以通过deamon.json来配置容器日志的最大size以及数目，或者在启动容器的时候配置也可以

Docker挂载为什么失效
1. Docker容器内的路径写错了
2. 挂载的路径写错了
3.  容器内默认运行用户是 容器root,而不是宿主机root,可能存在文件读写权限不够,容器无法访问挂载的文件
4.  "可能是SELinux或AppArmor限制，这些安全模块会阻止容器访问某些文件，"

解决方法:
1. 使用特权容器/改文件权限
2. 配置安全策略

Docker镜像为什么失效
1. 镜像打包的代码本身存在错误,只是打包时没报错,所以没办法正常启动
2. 镜像拉取失败
3. 存储空间不足
4. 网络不稳定,镜像拉取超时

如果要让容器访问宿主机的服务，应该用什么IP地址？
1.用主机的真实ip地址
2 docker0本身就是宿主机在docker网络中的ip地址，访问docker0就是访问主机

两个容器如何共享数据
用volumeMounts设置挂在共享区
apiVersion: v1
kind: Pod
metadata:
  name: shared-data-pod
spec:
  containers:
  - name: container1
    image: nginx
    volumeMounts:
    - name: shared-volume
      mountPath: /app/data

  - name: container2
    image: redis
    volumeMounts:
    - name: shared-volume
      mountPath: /app/data

  volumes:
  - name: shared-volume
    emptyDir: {}
## Docker基础概念

### 镜像结构认知
**分层结构（Layered Structure）**
- Docker 镜像由多层（Layer）叠加组成，每一层都是只读的文件系统
- 最底层通常是基础镜像（如 Ubuntu、Alpine）
- 每执行一次 Dockerfile 的 RUN/COPY/ADD 等命令，就会生成一层新的 Layer
- 镜像的所有层最终叠加成一个完整的文件系统，供容器使用

> Docker 镜像是由多层只读文件系统叠加组成的，具备分层复用、只读、可移植等特性。镜像本身是静态模板，容器则是镜像的运行实例，容器在镜像之上加一层可写层，实现应用的实际运行。镜像和容器的分离，使得应用交付和环境一致性变得非常简单高效。

### Docker三大核心
> Docker 的三大核心是镜像、容器和仓库。镜像是应用和环境的只读模板，容器是镜像的运行实例，仓库则负责镜像的集中存储和分发。这三者共同构成了 Docker 的完整生态，实现了应用的快速交付和环境一致性。

### 镜像内容组成
> 一份Docker镜像包含了运行容器所需的所有文件（包括操作系统环境、应用程序、依赖库、配置文件等），以及镜像的元数据和启动配置。镜像采用分层结构，每一层都是文件系统的快照，最终叠加形成完整的运行环境。

### Docker与虚拟机差异
> Docker 和虚拟机的主要区别在于资源隔离方式和资源占用：
> 
> Docker 是基于镜像分层的容器技术，通过 Dockerfile 逐步构建镜像，最终运行时只需在宿主机上启动一个进程，容器共享宿主机的操作系统内核，启动速度快，占用资源少。
> 
> 虚拟机则需要完整的操作系统和内核，每个虚拟机都是一个独立的系统，资源隔离更彻底，但启动慢、占用内存和磁盘空间更多。
> 
> 简单来说，Docker 更轻量，适合快速部署和弹性扩缩容；虚拟机更重，适合需要强隔离的场景。

在生产环境中，你发现一个Docker容器的内存使用率持续上升，最终被OOM Kill了。
请问：
你会用哪些具体的Docker命令来查看容器的资源使用情况？
如何设置容器的内存限制？
当容器被OOM Kill后，你如何查看相关的系统日志来确认具体原因？
1.会使用docker stats container——ID来实时查看docker的资源利用率
2.其次会使用docker inspect 来查看docker的资源配置情况。
3. 分配资源的命令我记得是docker run -n 500m


在Docker中，有几种网络模式。
请问：
bridge模式和host模式的主要区别是什么？
在什么场景下你会选择使用host网络模式？
docker主要有四中网络模式。
1.bridge模式，这种模式系统会创建一个docker0的虚拟网桥，然后从docker0的子网分配ip给我们的docker
2.host模式，这种模式docker和宿主机共享网络，外界能够直接 通过端口访问到我们的docker，但是这种模式docker如果占用了一个端口，那么宿主机就没办法再用这个端口了
3.container模式，这种模式是设置一个新建的docker和另一个docker共享network命名空间，它们共享ip和端口范围，不独立创建网卡，但是进程之间也是独立的.
4.最后一个是none模式，也是最安全的模式，这种模式不创建网卡网桥，也不分配ip，只有本地回环地址，无法与外界流量进行访问
一般情况下只有当对网络性能有一定要求，且端口充裕时才使用host模式

Docker镜像是分层存储的，请解释一下什么是镜像层？当你执行docker pull命令时，如果本地已经有相同的层，会发生什么？
镜像层是docker镜像的最小单位，每个镜像层都是只可读的，通过哈希来进行镜像层标识。docker的镜像层实际上就相当于我们dockerfile里的一个个命令，比如说RUN，比如说copy，比如说env，dockerfile里面的一个命令就相当于是一层镜像层，然后我们的docker是由多层镜像层一起封装而成的。如果本地已经有了相同的层，那就会复用已有的层来减少网络损耗以及存储空间。

我们知道，容器技术（如Docker）实现了进程间的资源隔离和视图隔离。这是通过利用Linux内核的两种核心技术来实现的。请问这两种技术分别是什么？并简要说明它们各自的作用。
对于视图隔离来说，是通过linux内核的namspace机制实现的，通过namespace，创建了容器的边界，让容器里面的进程看不到外面的进程。比如说，我们容器里面有自己的网络隔离，不同容器有自己的网络配置以及端口范围。同时，容器里面有自己pid隔离，各个容器都可以创建不同的独立进程，同时，容器之间的进程互相不可见，以及文件系统隔离，容器有一套自己的文件系统，有自己的根目录，在不挂载的情况下，无法直接访问宿主机的文件。
再有是资源隔离，其实也就是资源限制，通过controler group实现，类似于为容器可使用的资源进行配额管理，我们在容器创建之初就可以为容器分配资源，给容器一个独立的无法被宿主机进程占用的资源空间,也限制容器直接占用宿主机或其他容器的空间，防止资源抢占

一个 Docker 容器内的进程 PID 是 1，它在宿主机上的 PID 是多少？如何找到这个对应关系？
使用docker top 加容器名，返回的pid就是宿主机上的pid

docker的三大组件
容器镜像仓库

Docker的文件系统是什么
docker的文件系统是镜像分层加写时复制，docker会将多个只可读的镜像层堆叠到一起，最后当我们运行容器时，在镜像最上层加一个可写层，当我们需要复制修改删除时，都在这个可写层处理，比如说需要修改文件时，系统会先在可读层找到最近的目标文件，然后复制到可写层，我们最终在可写层修改应用，删除文件也是一样的，我们会在可写层创建一个标记文件，当容器访问时对应可读层的文件就会被屏蔽，看起来像是被删除了

docker孤儿容器是什么
docker孤儿容器是容器主进程退出，但是容器内还有其他进程正在运行

孤儿容器的状态下，容器还是存活的吗？要怎么处理以及防止
在docker角度上看，主进程pid 1已经死了，但是存在子进程运行，所以还是存活的。处理方式可以停止容器。防止可以在docker run时加个--init参数，或者在dockerfile中添加一个/sbin/tini的entrypoint

### 目录挂载方式
```bash
docker run -v /主机目录:/容器目录 镜像名
```

## Dockerfile命令详解

### 常用命令列表

#### 1. FROM
- **作用**: 指定基础镜像（必须是第一条指令）
- **示例**: `FROM ubuntu:20.04`
- **细节**: 可以多次出现（多阶段构建），每个阶段都要有 FROM

#### 2. RUN
- **作用**: 在构建镜像时执行命令，把结果写入镜像层
- **示例**: `RUN apt-get update && apt-get install -y nginx`
- **细节**: 每个 RUN 都会生成一个新层，建议合并多条命令减少层数

#### 3. CMD
- **作用**: 指定容器启动时默认要执行的命令（可被 docker run 覆盖）
- **示例**: `CMD ["nginx", "-g", "daemon off;"]`
- **细节**: 一个 Dockerfile 只能有一个 CMD，多个时只执行最后一个

#### 4. ENTRYPOINT
- **作用**: 指定容器启动时要执行的主命令（不易被覆盖）
- **示例**: `ENTRYPOINT ["python", "app.py"]`
- **细节**: 和 CMD 配合时，CMD 的内容会作为 ENTRYPOINT 的参数

#### 5. COPY
- **作用**: 把本地文件/目录复制到镜像中
- **示例**: `COPY ./src /app/src`
- **细节**: 只能复制构建上下文中的文件，权限和元数据不会保留

#### 6. ADD
- **作用**: 类似 COPY，但支持自动解压 tar 文件、支持 URL
- **示例**: `ADD app.tar.gz /app/`
- **细节**: 功能更强，但不推荐滥用，除非需要解压或远程下载

#### 7. ENV
- **作用**: 设置环境变量
- **示例**: `ENV LANG C.UTF-8`
- **细节**: 后续 RUN、CMD、ENTRYPOINT 都能用这些变量

#### 8. EXPOSE
- **作用**: 声明容器运行时要监听的端口（仅声明，无实际开放）
- **示例**: `EXPOSE 80`
- **细节**: 用于文档和自动化工具，实际端口映射需 docker run -p

#### 9. WORKDIR
- **作用**: 设置后续命令的工作目录
- **示例**: `WORKDIR /app`
- **细节**: 多次设置会层层嵌套

#### 10. VOLUME
- **作用**: 声明挂载点，建议数据持久化
- **示例**: `VOLUME /data`
- **细节**: 实际挂载需 docker run -v

#### 11. USER
- **作用**: 指定后续命令的执行用户
- **示例**: `USER nginx`
- **细节**: 提升安全性，避免用 root

#### 12. ARG
- **作用**: 定义构建参数（只在构建时有效）
- **示例**: `ARG VERSION=1.0`
- **细节**: 可用 docker build --build-arg 传参，构建后不可用

#### 13. HEALTHCHECK
- **作用**: 指定容器健康检查命令
- **示例**: `HEALTHCHECK CMD curl -f http://localhost/ || exit 1`
- **细节**: 用于监控容器健康状态

#### 14. LABEL
- **作用**: 为镜像添加元数据
- **示例**: `LABEL maintainer="me@example.com"`
- **细节**: 可用于镜像管理和自动化工具识别

#### 15. ONBUILD
- **作用**: 为后续继承此镜像的 Dockerfile 预设构建指令
- **示例**: `ONBUILD COPY . /app`
- **细节**: 常用于基础镜像的二次开发

### CMD vs ENTRYPOINT 区别
- **CMD**: 可被 docker run 的命令行参数覆盖，适合做默认参数
- **ENTRYPOINT**: 不易被覆盖，适合做主命令
- **组合用法**: ENTRYPOINT ["python"] + CMD ["app.py"]，最终执行 python app.py

### 面试高分话术
> Dockerfile 常用命令有 FROM、RUN、CMD、ENTRYPOINT、COPY、ADD、ENV、EXPOSE、WORKDIR、VOLUME、USER、ARG、HEALTHCHECK、LABEL、ONBUILD 等。RUN 用于构建时执行命令，CMD/ENTRYPOINT 用于容器启动时指定主命令，COPY/ADD 用于文件复制，ENV/ARG 用于参数和环境变量。CMD 和 ENTRYPOINT 的区别在于一个是默认参数、一个是主命令，组合使用更灵活。

在docker部署中遇到过哪些问题，你是怎么解决的，能举例分享一下吗
1.  碰到影响最深的是 一个容器文件权限的问题，当时是 挂载了宿主机配置文件，然后docker启动的时候显示配置文件 pressmison define，然后我看宿主机本地有内容，exec容器看也有内容，但就是启动不了。后面才知道是 docker会默认以dockerfile里面设置的user运行，如果没设置user就默认以root用户运行。

宿主机编译能运行，docker里不能运行，怎么排查的？
1. 看工作目录设置对了没，相关代码有没有copy到docker里面去。
2. 跟1相关，copy到工作目录的相关代码是以 原有的目录结构copy进去的，然后可能 CMD处 写错了启动命令，路径写错了
3. 结合以上两点，我们需要起个临时容器进到里面去，然后 看看目录结构正不正常。
4. 可能存在依赖没被打包进去，如果项目没使用requirement.txt来实现依赖版本控制的话可能就会有这个问题
5. 还有一个，如果 使用了文件挂载，但是该目录实际不存在也会导致不能运行 
6. 检查集群资源剩余情况，看是不是集群存储空间不够导致无法正常启动docker

如何查看容器资源占用？如何修改容器端口映射？数据是否会丢失？
# 查看特定容器
docker stats <container_id>
修改端口映射得删除容器再重新运行
数据是否丢失取决于有有没有持久化处理。如果没有持久化删除+删除容器就会丢失

