数据库
Mysql 慢查询排查思路
第一步：开启慢查询日志
 首先是开启我们的慢查询日志，将设置配置为ON，同时设置 超过两秒的查询，以及没有索引的查询都记录出来
第二步：分析慢查询日志
  使用mysqldumpslow分析慢查询日志，看哪些查询平均耗时最长，哪些耗时执行次数最多，重点就是 执行次数多且平均耗时长的
第三步：深入分析问题SQL
   下一步是 检查查询的type，看看是不是全表查询，如果是的话需要修正。同时查看有没有配置索引
第四步：优化查询和表结构
    "根据分析结果，我会进行针对性的优化。如果是索引问题，就添加合适的索引；如果是查询语句写得不好，就优化SQL语句，比如避免SELECT ，使用LIMIT限制结果集只返回一部分结果，不返回全部结果，优化JOIN的顺序将参数分离值较大的放左边。"
第五步：建立监控机制
设置慢查询监控告警，定期分析慢查询日志，及时发现和解决新的问题。

索引是什么
索引是数据库中用来快速定位和访问数据的数据结构，类似于目录

索引通过什么作用的
通过创建指向实际数据行的指针来加速查询操作

用docker装的数据库？目录怎么挂载的？
 “用docker装数据库时，目录挂载用-v参数，比如-v /my/data:/var/lib/mysql，这样可以把数据持久化到主机，防止容器删除后数据丢失。”

mysql binlog 目录里面有什么
binlog 文件：比如 mysql-bin.000001、mysql-bin.000002 这样一串编号的文件，每个文件记录了一段时间内的所有写操作（如INSERT、UPDATE、DELETE等）。
binlog 索引文件：比如 mysql-bin.index，里面记录了所有 binlog 文件的文件名列表，方便 MySQL 管理和查找

确定性和函数跟非确定性函数的区别

mysql它的水平扩展和垂直扩展
 垂直扩展：增加单机硬件资源来提升性能
 水平扩展： 增加服务器节点来分散负载

请简述 MySQL 常见的索引类型有哪些？B+树索引的原理是什么？为什么 InnoDB 默认使用 B+树而不是哈希或二叉树？请结合实际查询场景说明索引的优缺点。
常见索引类型有 普通索引，唯一索引，主键索引，联合索引
B+索引数的原理是 数据全都存储到叶子节点中，跟节点只存储索引信息，然后叶子结点之间通过链表相连。当需要遍历时自上而下进行遍历。
哈希树更适用于等值查询，而非范围查询或者排序。二叉树的树高，磁盘IO频率强，不适用于数据库查询。
索引可以提升查询速度，减少等待时间，同时减少全表扫描。但是索引过多会占用内存，也可能导致查询速度变慢，以及索引需要维护。

索引的缺点是什么
1.索引需要占据存储空间
2.索引本身维护就需要一定的时间成本，因为我们在进行表数据修改，比如插入删除时，还需要同步修改索引树 ，导致我们写入的性能变慢。同时索引太多也会的导致索引的查询速度变慢。

索引失效的常见原因是什么：
1.对索引本身使用了函数或者计算，我们的计算或者函数应该在等号的右边，比如age=21
2.使用了OR。而另一个查询条件不是索引
3.字符串没有添加双引号，导致隐式的类型转换发生。

数据页是什么
数据页是存储的物理单位，常代表一类索引值的多行数据。比如说 age为索引，那age=25的所有行都是该数据页中的一员

B+树的叶节点里存了什么
存储了索引值+指针，所以通过查询时，就能直接对比索引值从而找到对应的指针，找到对应的数据页


请解释一下MySQL中B+树索引的结构特点，以及为什么MySQL选择B+树而不是B树或者红黑树作为索引结构？
具体要求：
B+树和B树的主要区别是什么？
为什么不用红黑树做索引？
B+树在范围查询上有什么优势？
聚簇索引和非聚簇索引的区别？
1.B+数在叶节点上存储数据，根节点上只存储索引，同时叶节点之间通过链表相连。它的树高相对矮，遍历所需的时间短，磁盘io少。B树相较于B+树来说，它的叶节点之间没通过链表相连，同时全部的节点都存储数据。
2.红黑树是二叉树，树高相对较高，同时遍历需要中序遍历，时间长，且对磁盘io的访问频繁
3.在范围查询上，因为树高矮，所以需要的时间更短，同时叶姐点之间通过链表相连，需要遍历的节点也少，磁盘io少，适合范围查询
4.聚促索引是在叶节点上直接存储行数据，查询效率高，以减少磁盘io，但是会增大维护的难度，同时插入数据的成本较高。非聚促索引数叶节点上只存储索引，还需要再回表查询一次，劣势是查询速度较慢，但是插入数据快，更新数据也快。

binlog，redo log，undo log日志的区别
binlog主要用于数据库的主从复制，记录了有对数据库的修改操作。
redolog主要用于崩溃恢复，记录了有数据页的物理变更，方便崩溃的时候进行恢复
undolog主要用于事务的撤销和回滚，记录的是事务修改前的数据，来实现操作的原子性

面试官：“我们一个核心业务的数据库，采用的是 MySQL 主从复制架构，读写分离。最近监控发现，从库的数据同步延迟（Seconds_Behind_Master）偶尔会飙升到几分钟，虽然很快会恢复，但在延迟期间，业务从‘从库’读到了旧数据，导致了用户投诉。
1.首先是ping检查主从库之间的网络延迟
2.再次是登录到从库服务器。使用show slave status查看我们的从库日志状态，如果说是从库读取的日志位点，远远小于主库生成的位点，则代表是主从库之间的网络延迟或者是主库的IO压力过大导致的瓶颈
3.但是如果是sql位点远小于从库读取位点的话，则说明是sql语句执行过慢。可能是从库的cpu或者内存压力较大
为了应对这种情况，我们应该对架构上进行升级，第一是采用半同步复制机制，当至少有一个从库写入数据后，主库才会返回
第二个是采用延迟监控以及流量切换机制。引用数据库中间件不断读取主从库之间的延迟，当延迟过大时，切换读流流量值主库，避免用户读取到旧值


脑裂是什么，有什么危害，怎么解决
脑裂是在进行故障转移过程中，数据库从库间可能因为网络无法通信造成裂成了很多部分，而每个部分都觉得自己是唯一的部分，同时选举出多个主库。危害是多个主库同时进行写入操作会有冲突，当恢复后出现严重的数据一致性问题，各个数据库数据不一致。
解决方法是使用多数派原则，也就是只有当同意选举从库个数多于一半是才选出主库，否则不做选择，牺牲可用性保持数据一致性。同时，尽量选择奇数个从库与，因为多数派在出现分裂出很多部分时，奇数个从库总能选出多数派原则的主库

mysql是什么协议的服务，为什么。
mysql是四层传输层tcp协议的服务，有个例子是，假设我们可以通过浏览器或者api访问的，都是第七层https。
需要专门客户端连接的（比如navicat和redis-cli）都是第四层传输层的tcp服务

mysql的怎么进行备份
mysql有全量写入以及全量备份。一般来说，我们可以使用mysqldump来生成.sql的文件，进行备份。可以使用全量备份加增量备份的方式，每周日进行全量备份，每天复制binlog做增量备份，在恢复时，先恢复全量备份，再应用增量binlog

增量备份binlog会具体要怎么配置
首先我们要获取从myldumpup全量备份的结束位置，将这个结束位置作为binlog开始写入的起始位置。

全量备份怎么恢复，以及结束位置怎么获取
使用source 文件名.sql 进行全量备份恢复
然后我们在文件里面会明文写着全量备份时所处的binlog文件名，以及对应的结束位置

缓存和数据库怎么保证数据一致性？
面对读多写少的业务场景，可以使用先更新数据库，再删缓存的方式。不过这种方式在高并发的情况下，可能读到没删除的缓存，从而读到脏数据。
进阶方案是延时双删，也就是先更新数据库，再删缓存，sleep一小段时间，再删缓存。不过这种方案sleep时间不好确定，对性能有影响

必须保证强一致性应该怎么做
理论上来说，保证强一致性会牺牲性能。如果说必须保证强一致性，我们可以应用层只将数据写入缓存，由缓存对数据库进行写入操作，当缓存跟数据库都更新之后，才返回成功。不过这种情况的性能开销很大

binlog的存储顺序
binlog是顺序存储的，每个binlog文件相互独立，我们可以设置binlog分片方式，比如说每天，比如说达到多少g是分下一片

mysql的索引为什么会影响写入性能
因为我们在执行写入更新删除等操作时，不只是在表里进行操作，mysql同时还需要在索引数上做对应的索引条目更新，也可能需要调整树的结构来保持平衡

调整树的结构来保持平衡是什么意思
b+树会保持自平衡来使得遍历到每个位置的时间大概相等，当出现删除或插入等操作时，b+树会进行页分裂或者页合并来实现保持树配合

innonDB是什么，有什么优势
innonDB是mysql最新最好用的存储引擎。它实现了事务的原子性一致性持久性隔离性，支持行级锁外键以及崩溃恢复

事务的一致性具体指的是什么意思
事务的一致性关注的是结果，关心数据的正确性。保证数据库的事务是合乎逻辑的，符合业务逻辑的，同时不会处在某个中间状态，会从一个合法状态变成另一个合法状态
·

delete和truncate和drop的区别
delete为删除特定行，可带where条件
turncate删除表数据，但保留表结构
drop全都删除

UNION和UNION ALL有什么区别？
对查询到的结果集进行合并，union速度较慢，但是会去重。union all不会去重

唯一索引和主键索引的区别
主键索引：定义主键自定创建。值不可重复，不可为空，每表只有一个主键
唯一索引：需要手动创建，值不可重复，但是可为NULL，每表可以有多个唯一索引

唯一索引和普通索引的区别
普通索引可为空可重复可多个
唯一索引可为空但是不可重复，可多个

主键到底是什么
主键是表中每一行的“身份证号”，用来区分不同的记录

什么是死锁？如何预防死锁？
死锁是多个事物之间互相等待资源。预防死锁的方式有
1. 添加锁超时机制
2. 使用信号量进行资源访问顺序控制
3. 对读操作加共享锁，写操作加排他锁
4. 减少事务持有锁的时间

使用信号量进行资源访问顺序控制是什么意思
给每个资源分配一个编号，所有事务按相同的顺序访问资源，避免循环等待

对读操作加共享锁，会导致读到的数据实际是被修改过的吗？
读数据读到的是一致性快照，是数据库在某个时间段内的未修改数据

事务隔离级别有哪些：
1读未提交：可以读取到其他事务未提交的数据，可能导致脏读的情况出现，性能最好
2.读已提交，可以读取到其他事务已提交的数据，可能产生不可重复读
3. 可重复读，通过在事务初期创建对已经存在的行数据快照，使得同一个事务内多次读取同一行数据时候结果一只，但是可能导致多次查询的行数不一样

脏读和不可重复读和幻读的区别
脏读的意思是读到其他并发事务未提交的数据
不可重复读的意思是两次读取的数据不一致
幻读的意思是，两次查询返回的行数不一致

为什么会产生幻读
因为可重复读机制是对已存在的行创建数据快照，它无法阻止其其他事务插入新行

mysql自动提交是什么
就是会把每一条sql语句看作分离的个体，执行时自动提交到数据库，无需手动提交commit

mysql怎么开启事务
使用start transaction，commit，rollback来开启显示的事务控制，提交以及回滚

mysql什么时候用到事务
需要数据强一致性，或者是批量处理数据，业务逻辑复杂的时候

MVCC是什么
MVCC是通过保存数据的多个版本快照来实现并发控制的一种方式.它同时也是可重复读的手段之一

MVCC的实现机制
MVCC会每条数据保存多个历史版本快照来实现并发控制,同时为事务分配唯一递增ID,事务只能看到在它之前已经提交的数据,同时假设需要修改数据,数据库不会直接覆盖原数据,而是根据创建它的事务编号来创建新版本

mysql怎么保证内部数据一致性
1.启用事务机制
2.对关键操作加排他锁
3.设置事务隔离机制，比如说读已提交或者可重复读
4.主从复制机制，使用半同步模式
5.应用层引入幂等性以及数据校验

mysq怎么保证数据库之间的数据一致性，即mysql跟redis之间的数据一致性
没有两全的方案，我们要做的是根据业务进行数据一致性，性能，成本之间的成本
1. 延时双删，想删除缓存中的对应数据，再写入到mysql，sleep一段时间，再删除一次redis中的缓存，不过这种情况其实是一种妥协，对性能有一定影响
2. 对于强一致性要求，性能也取舍的场景，我们可以只将数据写入到redis，只由redis将数据写入到mysql，等写入后才返回，不过这种模式对性能影响很大

如果不限成本，有没有能同时保证mysql跟缓存之间数据强一致性与性能的方案
说白了就是堆设备，全用内存存储数据，使用高性能cpu。服务器之间用光纤连接，延迟极低。一份数据同时写入到全部服务器，都写成功时才返回，读时可以从任意一台读

mysql怎么保证高可用
1. 主从复制机制，同时开启故障转移，使得能够有从库在主库故障时晋升。
2. 同城多活实现高可用，在同城多地多个机房配置mysql，避免单机房故障导致宕机
3. 异地多活实现容灾，在多地设置多个主库，主库之间互相双向同步保证数据一致性，不过这种情况对数据一致性会有一定影响，需要根据业务做数据一致性配置。
4. 定期备份，3-2-1的备份机制，也就是三个备份文件，两种存储介质，至少一个在异地
5. 冷备份机制， 在异地设置一份冷备份

说说mysql的两阶段提交机制
首先是prepare阶段，先将数据写入到redo log，并切换为prepare模式。到commit阶段时，会将数据写入binlog，并修改状态为commit。假设期间出现崩溃，如果是在写入binlog前崩溃，那就事务回滚。如果在写入binlog后崩溃，就恢复数据

UNION用于什么场景，和UNION ALL有什么区别，和left join有什么区别
UNION用于两个表上下的拼接，也就是增加的是行数。UNION会进行去重，较慢，UNION ALL不进行去重，较快。left join用于把两个表进行左右拼接

# **MySQL主从与高可用架构**

oracle数据库高可用怎么做
我会采用主从复制+读写分离的高可用架构，主库负责写，从库负责读，并通过MHA、Orchestrator等高可用组件实现主库故障自动切换。为保证数据一致性，我会启用半同步复制，实时监控主从延迟，备份时选择延迟最小的从库或主库，并使用一致性快照技术。对于跨库操作，采用分布式事务或全局唯一ID，应用层设计幂等和重试机制，确保在各种故障和切换场景下数据的一致性和高可用性。

mysql有哪些锁
 MySQL的锁主要分为表级锁、行级锁、页面锁；按性质分为共享锁、排他锁、意向锁；按实现分为记录锁、间隙锁、临键锁、插入意向锁。
 1. 表级锁
作用：锁住整张表
什么时候用：修改表结构、MyISAM引擎
影响：其他事务无法访问这张表
例子：ALTER TABLE 时整个表被锁住
2. 行级锁
作用：只锁住特定的行
什么时候用：InnoDB引擎，高并发场景
影响：只影响被锁的行，其他行可以正常访问
例子：UPDATE users SET name='张三' WHERE id=1 只锁id=1这行
3. 共享锁（S锁）
作用：允许多个事务同时读，但不允许写
什么时候用：读操作，防止数据被修改
影响：其他事务可以读，但不能写
例子：SELECT * FROM users WHERE id=1 LOCK IN SHARE MODE
4. 排他锁（X锁）
作用：只允许一个事务读写，其他事务都不能访问
什么时候用：写操作，保证数据一致性
影响：其他事务不能读也不能写
例子：UPDATE、DELETE、INSERT 操作
5. 记录锁
作用：锁住索引记录
什么时候用：精确查询（主键、唯一索引）
影响：只锁住具体的记录
例子：UPDATE users SET balance=100 WHERE id=1
6. 间隙锁
作用：锁住索引记录之间的空隙
什么时候用：防止幻读，RR隔离级别
影响：防止其他事务在范围内插入数据
例子：SELECT * FROM users WHERE age BETWEEN 20 AND 30 FOR UPDATE
7. 临键锁
作用：记录锁 + 间隙锁的组合
什么时候用：InnoDB默认的锁机制
影响：既锁记录又锁间隙
例子：范围查询时的默认锁机制
8. 插入意向锁
作用：插入操作专用的锁
什么时候用：提高并发插入性能
影响：多个插入操作可以并发进行
例子：INSERT INTO users VALUES (...)

行级锁和表级锁竞争会导致什么
"行级锁和表级锁竞争会导致锁升级，当行级锁数量过多时，InnoDB会自动升级为表级锁。这会导致并发度下降、响应时间增加、吞吐量降低。避免方法是分批处理、控制锁数量、使用合适的索引，同时要监控锁状态，及时发现和处理锁竞争问题。"

在MySQL中，什么是事务的ACID特性？请详细解释每个特性的含义，并说明在高并发场景下，如何保证事务的一致性？
分别是：
1. 原子性，也就是一起实现，一起回滚。比如说我们的转账操作，a转账给b，a少钱b加钱，一个操作没实现就一起回滚
2. 一致性: 数据库从一个一致状态，转化为另一个一致状态
3. 隔离性：并发事务之间不会互相影响，通过锁机制以及多版本并发机制实现
4. 持久性：事物提交之后，即使系统崩溃也会持久保存
保持事物一致性的方法有：
1. 锁机制：行锁，表锁，间隙锁，意向锁，排他锁，共享锁等
2. 乐观锁悲观锁机制:通关版号
3. 事务隔离级别
乐观锁：先操作再解决冲突，通过版本号以及时间戳判断有没有更改，适合读操作。
悲观锁：先上锁再进行操作，适合写操作

## 主从原理
MySQL主从复制基于**二进制日志(binlog)**实现，通过异步复制机制将主库的数据变更同步到从库。

### 应用场景
- 读写分离: 主库写，从库读
- 数据备份: 从库作为热备
- 故障切换: 主库故障时从库接管

---

主往备同步的时候卡住怎么办？
主库往备库（从库）同步数据时"卡住"是实际运维中常见的问题。常见表现为：主库binlog已经写入，但从库的Seconds_Behind_Master变大，延迟严重，甚至不再推进。
一、常见原因
网络问题
主从之间网络抖动、丢包、带宽不足，导致binlog传输慢或中断。
从库SQL线程卡住
从库在重放binlog时，遇到大事务、慢SQL、锁等待、死锁等，导致SQL线程阻塞。
主库binlog未同步
主库binlog未及时推送到从库，可能是IO线程异常。
从库磁盘/CPU资源瓶颈
从库磁盘IO高、CPU高，导致SQL线程处理能力下降。
表结构不一致
主从表结构不一致，导致同步SQL报错，SQL线程停止。
大事务/批量操作
主库执行了大事务或批量DDL/DML，从库需要很长时间才能重放。
二、排查步骤
查看主从状态
   SHOW SLAVE STATUS\G
重点关注：
Seconds_Behind_Master（延迟秒数）
Slave_IO_Running、Slave_SQL_Running（是否Yes）
Last_IO_Error、Last_SQL_Error（是否有报错）
检查从库资源
top、iostat、vmstat 查看CPU、内存、磁盘IO是否异常。
查看慢SQL和锁等待
show processlist; 看是否有SQL卡住或锁等待。
检查information_schema.innodb_trx、innodb_locks等。
检查网络状况
ping、traceroute 检查主从之间网络延迟和丢包。
检查表结构一致性
对比主从表结构，确认没有差异。
三、处理建议
网络问题
优化网络，必要时切换到更稳定的链路或机房。
SQL线程卡住
找到慢SQL或锁等待的语句，优化SQL或手动kill阻塞的会话。
如遇到大事务，可考虑临时提升从库硬件资源。
主从表结构不一致
修正表结构，保证主从一致。
从库资源瓶颈
扩容CPU/内存/磁盘，或迁移到性能更好的服务器。
大事务/批量操作
避免主库执行大事务，分批提交。
等待从库慢慢追上，期间可临时切换读流量到延迟小的从库。
同步线程异常
如果Slave_IO_Running或Slave_SQL_Running为No，可尝试：
     STOP SLAVE;
     START SLAVE;
如有报错，根据Last_SQL_Error具体修复。
四、面试答题万能句式
> 主往备同步卡住时，首先要通过SHOW SLAVE STATUS排查是IO线程还是SQL线程卡住，关注是否有报错、延迟、资源瓶颈或锁等待。常见原因包括网络问题、慢SQL、大事务、表结构不一致等。处理时要针对具体原因优化网络、SQL、资源，必要时重启同步线程或修正表结构，确保主从同步恢复正常。

怎么判断主和备的数据是否一致？
（1）pt-table-checksum（推荐，Percona Toolkit）
作用：对主从表数据做校验和比对，发现数据不一致的表和行。
用法示例（在主库执行）：
Apply to Study.md
Run
检查结果会同步到从库，发现不一致会有告警。
判断主备数据是否一致，首先要通过SHOW SLAVE STATUS检查同步线程和延迟，其次可用pt-table-checksum等工具对主从表数据做校验和比对，发现并修复不一致的数据。对于关键表，还可以定期做业务层抽样校验，确保主从数据完全一致。

主从复制中有哪些线程
三大进程，主库的binlog，从库的IO以及SQL线程。对于初次建立连接来说，从库的IO线程会连接到主库，主库对从库进行鉴权，无误后拉起binlog线程，binlong线程往主库发送binlog，然后IO线程读取binlog并将其写入到本地的中继日志中，最后是SQL读取中继日志并执行操作

binlog有哪三种记录模式
1. 语句模式：记录修改的原始sql，优势是日志小，占用磁盘和带宽少，劣势是不安全，对于NOW（）函数等不确定函数在主从库执行结果可能不一致
2. 行模式：记录行修改前后的数据值，优势是安全，劣势是日志大，当update修改了太多行时，日志量会暴增。
3. 混合模式：也是目前binlog的默认模式，mysql会自动判断sql语句的安全性，对安全sql使用语句模式，不安全使用行模式

## 读写分离下备份一致性问题


场景题：分库分表，几十亿的qq号码要存起来怎么设计数据库，怎么设计索引保证分布均匀？
 1. 分库分表设计
分片目标：解决单表/单库数据量过大导致的性能瓶颈，提升查询和写入效率，保证数据分布均匀。
分片方式：采用哈希分片，以qq号为分片键。
例如：hash(qq号) % N，N为总分片数（如128、256等），结果决定数据落在哪个库/表。
这样可以让数据在所有分库分表中均匀分布，避免热点。
分库分表路由示例
先对qq号做hash，决定库，再对qq号做hash，决定表。
例如：128个库，每库128张表，总共16384张表。
2. 表结构与索引设计
主键设计：
如果qq号本身唯一，可以直接用qq号作为主键。
如果有其他业务需求（如允许同一个qq号有多条记录），可以用分布式ID（如雪花ID）做主键，qq号单独建索引。
分布均匀的索引设计：
分片键（qq号）：作为分库分表的依据，必须建索引，便于高效定位。
唯一性需求：如果qq号唯一，直接建唯一索引或主键即可。
联合索引：如有其他查询需求，可根据业务场景建立联合索引（如qq号+时间、qq号+类型等）。
SQL示例（假设qq号唯一）：
4. 答题模板总结
> 对于几十亿的qq号码存储，建议采用分库分表架构。以qq号为分片键，采用哈希分片（如hash(qq号)%N），将数据均匀分布到多个库和表中。表结构上，qq号可作为主键或唯一索引，保证唯一性和高效查询。通过合理的分片键选择和分片数设计，可以有效避免数据倾斜，保证分布均匀，提升系统的扩展性和性能。

分库分表是什么意思
分库：将大型数据库拆分为很多小数据库。
分表: 将大表拆分为很多小表
分库分表方式：按业务模块拆分/数据特征拆分

**读写分离有没有可能备份的数据要比主的少？**

答案是：有可能！

### 原因分析
在MySQL主从复制（读写分离）架构下，主库负责写操作，从库负责读操作和备份。但主从复制是异步（或半同步）的：
- **异步复制**：主库写入事务后立即返回，binlog异步传给从库，从库再重放日志。主库和从库之间有"延迟"。
- **半同步复制**：主库写入后，至少有一个从库确认收到binlog才返回，但从库数据应用仍有延迟。
- **全同步复制（极少用）**：主库必须等所有从库都写入成功才返回，性能很差。

因此：
- 如果在从库延迟期间进行备份，从库的数据可能比主库"少"——即缺少主库刚刚写入但还没同步过来的数据。
- 这就是所谓的"主从延迟"或"复制延迟"问题。

---

# **高可用架构设计与数据一致性**

## 架构设计思路
我会采用主从复制+读写分离的高可用架构，主库负责写，从库负责读，并通过MHA、Orchestrator等高可用组件实现主库故障自动切换。为保证数据一致性，我会启用半同步复制，实时监控主从延迟，备份时选择延迟最小的从库或主库，并使用一致性快照技术。对于跨库操作，采用分布式事务或全局唯一ID，应用层设计幂等和重试机制，确保在各种故障和切换场景下数据的一致性和高可用性。

---

## 分布式事务、全局唯一ID、幂等与重试机制

### 1. 分布式事务
- **场景举例**：你有两个数据库（比如订单库和库存库），下单时要同时写入这两个库。如果只写成功一个，另一个失败，就会出现数据不一致（比如钱扣了但没减库存）。
- **分布式事务就是**：让多个数据库的操作，要么全部成功，要么全部失败，保证数据一致。
- **常见实现方式**：
  - 两阶段提交（2PC）：先让所有库都"准备好"，都说OK后再一起提交。
  - XA事务：MySQL支持的分布式事务协议。
- 但分布式事务实现复杂，性能也会受影响，所以一般能不用就不用。

### 2. 全局唯一ID
- **场景举例**：你有多个数据库或多台服务器，都要生成订单号。如果大家都用自增ID，可能会重复（比如A库生成1，B库也生成1）。
- **全局唯一ID就是**：无论在哪台服务器、哪个库生成，都不会重复的ID。
- **常见做法**：
  - 雪花算法（Snowflake）：用时间戳+机器号+自增数拼成唯一ID。
  - UUID：全球唯一标识符。

### 3. 应用层幂等和重试机制
- **幂等（mì děng）**
  - **意思**：同一个操作，执行一次和执行多次，结果都一样。
  - **举例**：比如你点了两次"支付"，只会扣一次钱。比如你发了两次"确认收货"，订单状态还是"已收货"。
  - **为什么要幂等？** 网络不好、服务超时时，系统可能会自动重试请求。没有幂等，可能会出现多扣钱、多发货等问题。
- **重试机制**
  - **意思**：某个操作失败了，系统会自动再试一次，直到成功或超过最大次数。
  - **举例**：下单时网络抖动，第一次没成功，系统自动再发一次请求。

> 分布式事务和全局唯一ID，是为了解决多库多机数据一致性和唯一性问题；幂等和重试机制，是为了解决网络抖动、服务异常时，重复请求不会导致数据错乱。

### 幂等是怎么实现的
幂等性可以通过唯一索引、幂等Token、先查后写、去重表等方式实现。核心思想是让每个操作有唯一标识，服务端能识别并拦截重复请求，保证多次执行结果一致。

---

## 常用存储引擎
MySQL常用的存储引擎有InnoDB（支持事务、行级锁、外键，是默认引擎）、MyISAM（不支持事务，表级锁，适合读多写少）、MEMORY（内存型，速度快但数据不持久）、ARCHIVE（归档型，适合历史数据）、CSV（文本型，便于数据交换）等。实际生产中，绝大多数业务场景推荐使用InnoDB。



redis

redis这种，它跟传统的数据库有什么区别
 Redis与传统数据库的主要区别：
> - 存储介质：Redis基于内存存储，传统数据库基于磁盘
> - 性能：Redis读写速度极快，适合缓存场景
> - 数据结构：Redis支持字符串、哈希、列表、集合等丰富数据结构
> - 持久化：Redis可配置RDB/AOF持久化，传统数据库默认持久化
> - 应用场景：Redis主要用于缓存、会话存储，传统数据库用于事务处理和数据持久化



redis主从同步机制
redis是异步主从复制，主库写数据后立即返回，从库异步同步。
从库使用命令与主库连接，当主库进行写入操作时，会将操作通过复制流发送给从库，从库执行操作

redis怎么实现管道采集

Redis变慢怎么排查？
1. 检查是不是连接池不够了，需要跟业务协调是不是业务量增大，查表需求增多了，如果是可能需要扩充连接池
2. 查看部署了redis服务器的CPU,内存，存储情况，也是跟业务协调，然后评估要不要扩大资源分配，在业务低峰期重启，并调整maxmemory策略。
3. 查看是不是慢查询太多了。
4. 用ping检查一下网络延迟
5. 如果是主从架构，虽然redis是异步，但网络问题可能影响性能，所以也得检查从库状态

redis慢查询怎么优化
"Redis没有索引，主要靠优化数据结构：
> - 避免大key，把大key拆分成小key
> - 用Hash代替多个String，减少key数量
> - 用Pipeline批量操作，减少网络往返
> - 避免KEYS等慢命令，用SCAN代替
> - 复杂操作用Lua脚本，减少网络交互"

redis的基本数据类型有哪些
String字符串
list链表
set集合
zset有序集合
hash哈希

为什么Redis这么快？从数据结构角度分析
一是redis直接存储到内存上
二是redis是单线程，避免了上下文切换
三是redis有高效数据结构，根据不同场景优化，根据数据量的大小对数据类型进行优化。

采用多线程会让redis速度更快吗？为什么要使用单线程

Redis的过期策略有哪些？
1.惰性删除，只有在访问的时候删除过期缓存
2.定期删除，定期删除过期缓存
3.内存淘汰，在内存不足时根据策略删除一部分

redis
说说缓存穿透，缓存雪崩，缓存击穿分别是什么，以及怎么解决
1.要查询某个不存在的数据，导致缓存里面查不到的东西，数据库里面查不到，一直都拿到数据库，这就是缓存穿透。
解决方案是1.哪怕数据库里面是空值，也在缓存处存储个对应空值，避免一直打到数据库 2.设置布尔过滤器
2.雪崩也就是多个缓存同时过期，导致分撒的请求同时请求到数据库，数据库压力增大
解决方案是1.设置随机过期时间，不让它过期时间一致。2.采用多级缓存，本地也留缓存，减少雪崩量。
3.系统启动时先预热加载热点数据。4.当数据库压力过大时，直接进行熔断，返回空值
3.缓存击穿是某个热点key过期,导致大量的并发请求同时打到数据库.
解决方案是:1.上互斥锁,只让一个请求访问到数据库,返回后更新缓存.2.设置热点key永不过期.


redis集群各个节点上的基本单位是什么
在Redis集群（Cluster）中，各个节点上的基本单位是"槽（slot）"
节点（Node）：集群中的一台Redis服务器，可能是主节点（Master）或从节点（Slave）。
槽（Slot）：数据分片的最小单元，决定key的分布。
主节点负责槽：每个主节点负责若干个槽，槽的分配可以动态调整，实现数据迁移和扩容。

讲一下redis持久化机制
持久化机制有两种，一种是定期做生成数据集的快照，优点是文件紧凑，缺点是最后一次快照后的数据可能丢失。另一种是做写入操作命令的记录，记录到日志文件中，优点是数据安全性高，缺点是文件体积大

Redis哨兵模式？
"Redis哨兵模式是一套高可用解决方案，通过多个哨兵进程监控主从节点状态，实现主节点故障时的自动切换和通知。它能自动选举新主节点，通知客户端更新连接，保障Redis服务的高可用性，是中小型Redis集群常用的高可用方案。"
哨兵模式的核心作用
自动故障转移：当主节点（master）宕机时，哨兵会自动将某个从节点（slave）提升为新的主节点，并通知客户端更新主节点地址。
监控：持续监控主从节点的运行状态，发现异常及时报警。
通知：通过API或配置，通知运维人员或其他系统节点的状态变化。
配置提供者：客户端可以通过哨兵获取当前主节点的地址，实现自动感知主从切换。
监控：哨兵进程不断PING主从节点，判断其是否存活。
主观下线：某个哨兵发现主节点不可达，标记为"主观下线"。
客观下线：多数哨兵都认为主节点不可达，达成共识后，标记为"客观下线"。
自动故障转移：
选举一个从节点为新的主节点（基于优先级、复制进度等）。
让其他从节点重新复制新主节点。
通知客户端主节点地址变更。
通知：通过API、脚本、配置等方式通知外部系统。

一个key是如何定位到具体的主机的
对给定key取哈希，对哈希值取16384的模，得到哈希槽位
在集群创建之初，16384就就被均匀分配给了各个节点，通过映射表就可以找到哈希槽位的主机


Redis三兄弟是什么
redis核心服务器模式，redis哨兵模式，redis集群模式

prometheus 有哪些组件，Grafana怎么集成到prometheus上
Prometheus Server: 主服务器，抓取和存储时间序列数据
Client Libraries: 客户端库，用于应用程序代码埋点
Push Gateway: 推送网关，支持短生命周期作业
Exporters: 导出器，为HAProxy、StatsD、Graphite等服务提供指标
node_exporter,mysqld_exporter
Alertmanager: 告警管理器，处理告警

解释一下“旁路缓存”（Cache-Aside）模式。它和“读穿/写穿”（Read/Write-Through）有什么区别？
旁路缓存就是在查询时先查缓存的，如果没有再查数据库的，同时将数据库返回到写到缓存里。
在写入操作时，直接写入数据库，然后将缓存中的对应条目删除。但是可能有缓存-数据库不一致的风险。
读穿/写穿策略是，在查询时先查缓存的，缓存没有再由缓存服务去访问数据库。然后在写入操作时，直接将数据写入缓存，缓存服务写入数据库。应用代码简单，但对缓存服务的实现要求高



如果让你用shell脚本实现定时备份，你会怎么实现 
1. 编写备份脚本（如 backup.sh）
#!/bin/bash

# 备份目录
SRC_DIR="/data/important"
# 备份存放目录
DEST_DIR="/backup"
# 备份文件名，带日期
BACKUP_NAME="important_$(date +%Y%m%d_%H%M%S).tar.gz"

# 创建备份目录（如不存在）
mkdir -p $DEST_DIR

# 打包备份
tar -czf $DEST_DIR/$BACKUP_NAME $SRC_DIR

# 可选：删除7天前的备份
find $DEST_DIR -type f -mtime +7 -name "*.tar.gz" -exec rm -f {} \;

2. 设置定时任务（crontab）
比如每天凌晨2点自动备份：

crontab -e
# 添加一行
0 2 * * * /bin/bash /path/to/backup.sh

# **主往备同步卡住的排查与处理**

## 一、常见原因
- **网络问题**：主从之间网络抖动、丢包、带宽不足，导致binlog传输慢或中断。
- **从库SQL线程卡住**：从库在重放binlog时，遇到大事务、慢SQL、锁等待、死锁等，导致SQL线程阻塞。
- **主库binlog未同步**：主库binlog未及时推送到从库，可能是IO线程异常。
- **从库磁盘/CPU资源瓶颈**：从库磁盘IO高、CPU高，导致SQL线程处理能力下降。
- **表结构不一致**：主从表结构不一致，导致同步SQL报错，SQL线程停止。
- **大事务/批量操作**：主库执行了大事务或批量DDL/DML，从库需要很长时间才能重放。

---

## 二、排查步骤
1. **查看主从状态**
   ```sql
   SHOW SLAVE STATUS\G
   ```
   重点关注：
   - `Seconds_Behind_Master`（延迟秒数）
   - `Slave_IO_Running`、`Slave_SQL_Running`（是否Yes）
   - `Last_IO_Error`、`Last_SQL_Error`（是否有报错）
2. **检查从库资源**
   - `top`、`iostat`、`vmstat` 查看CPU、内存、磁盘IO是否异常。
3. **查看慢SQL和锁等待**
   - `show processlist;` 看是否有SQL卡住或锁等待。
   - 检查`information_schema.innodb_trx`、`innodb_locks`等。
4. **检查网络状况**
   - `ping`、`traceroute` 检查主从之间网络延迟和丢包。
5. **检查表结构一致性**
   - 对比主从表结构，确认没有差异。

---

## 三、处理建议
- **网络问题**：优化网络，必要时切换到更稳定的链路或机房。
- **SQL线程卡住**：找到慢SQL或锁等待的语句，优化SQL或手动kill阻塞的会话。如遇到大事务，可考虑临时提升从库硬件资源。
- **主从表结构不一致**：修正表结构，保证主从一致。
- **从库资源瓶颈**：扩容CPU/内存/磁盘，或迁移到性能更好的服务器。
- **大事务/批量操作**：避免主库执行大事务，分批提交。等待从库慢慢追上，期间可临时切换读流量到延迟小的从库。
- **同步线程异常**：如果`Slave_IO_Running`或`Slave_SQL_Running`为No，可尝试：
  ```sql
  STOP SLAVE;
  START SLAVE;
  ```
  如有报错，根据`Last_SQL_Error`具体修复。

---

## 四、面试答题万能句式
> 主往备同步卡住时，首先要通过SHOW SLAVE STATUS排查是IO线程还是SQL线程卡住，关注是否有报错、延迟、资源瓶颈或锁等待。常见原因包括网络问题、慢SQL、大事务、表结构不一致等。处理时要针对具体原因优化网络、SQL、资源，必要时重启同步线程或修正表结构，确保主从同步恢复正常。

---

# **主备数据一致性校验方法**

## 1. pt-table-checksum（推荐，Percona Toolkit）
- **作用**：对主从表数据做校验和比对，发现数据不一致的表和行。
- **用法示例**（在主库执行）：
  ```bash
  pt-table-checksum --user=xxx --password=xxx --host=主库IP
  ```
- 检查结果会同步到从库，发现不一致会有告警。

## 2. 复制状态检查
- 通过`SHOW SLAVE STATUS`检查同步线程和延迟。

## 3. 业务层抽样校验
- 对于关键表，还可以定期做业务层抽样校验，确保主从数据完全一致。

---

## 面试答题万能句式
> 判断主备数据是否一致，首先要通过SHOW SLAVE STATUS检查同步线程和延迟，其次可用pt-table-checksum等工具对主从表数据做校验和比对，发现并修复不一致的数据。对于关键表，还可以定期做业务层抽样校验，确保主从数据完全一致。
