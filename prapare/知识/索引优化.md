1. 开启慢查询日志，设置慢阈值为1，记录没有使用索引的查询（通常是 my.cnf 或 my.ini）
# 开启慢查询日志功能
slow_query_log = 1

# 指定日志文件存放路径
slow_query_log_file = /var/log/mysql/mysql-slow.log

# 设置“慢”的阈值，执行时间超过1秒的查询被记录
long_query_time = 1

# (可选，但强烈推荐) 记录没有使用索引的查询
log_queries_not_using_indexes = 1

工具二：实时观察 (SHOW PROCESSLIST;)
怎么用？ 在MySQL客户端里直接运行 SHOW PROCESSLIST;。
看什么？ 你会看到一个列表，每一行代表一个连接。重点关注这几列：
Time: 这个连接已经执行了多长时间（秒）。如果一个查询的Time持续很高，比如几十秒，那它肯定有问题。
State: 连接当前的状态。如果看到 Sending data、Copying to tmp table、Using filesort、locked 等状态持续很长时间，都是危险信号，说明查询正在进行非常耗费资源的操作。
Info: 正在执行的SQL语句。
第2步：分析——解读EXPLAIN执行计划
找到了可疑的SQL后，你需要用EXPLAIN来分析它的“病理报告”。这是整个优化过程的灵魂。

EXPLAIN SELECT ...; 会返回一张表，这张表详细描述了MySQL将如何执行你的查询。我们来逐一解析最重要的几列：

1.type (访问类型): 这是最重要的指标，没有之一！ 它揭示了MySQL查找数据的方式。
ALL (全表扫描): 最坏的情况。像在一本没有目录的字典里找一个词，只能从第一页翻到最后一页。这是我们优化的首要目标，必须消灭它！
index (全索引扫描): 比ALL稍好。就像字典有目录，但你要找的词不在目录里，于是你把整个目录从头到尾看了一遍。虽然比翻整本字典快，但依然很慢。
range (范围扫描): 比较好的情况。比如查找emp_no > 50000的员工，MySQL可以通过索引快速定位到50000的位置，然后向后扫描。
ref (非唯一索引查找): 很好的情况。通过一个普通索引（非唯一的）来查找。比如按first_name查找，可能会找到多个同名的人。
eq_ref (唯一索引查找): 优秀。通常出现在多表连接（JOIN）中，用一个表的主键或唯一键去关联另一张表。
const / system: 顶级水平。当查询主键或唯一索引时，MySQL一次就能定位到数据，快如闪电。

2.key (使用的索引): MySQL最终决定使用哪个索引来执行查询。如果这里是NULL，那就意味着没有使用任何索引，这通常会导致type为ALL。

3..rows (扫描行数): MySQL预估为了找到结果需要读取多少行数据。这个数字越小，查询成本越低。一个好的查询，rows应该很小。如果rows是一个巨大的数字（比如几十万），那查询肯定快不了。

4.Extra (额外信息): 这里包含了很多关键的“批注”，告诉你一些额外发生的事情。
Using filesort: 坏信号。说明MySQL无法利用索引来完成排序，必须在内存或硬盘上进行额外的排序操作，非常耗时。通常是因为ORDER BY的字段没有索引。
Using temporary: 非常坏的信号。说明MySQL需要创建一个临时表来处理查询，这会极大地拖慢速度。通常出现在复杂的GROUP BY或UNION操作中。
Using index: 绝佳的信号！ 这叫“覆盖索引”。意思是查询所需的所有数据，只通过读取索引就能全部获得，根本不需要再去访问原始的数据表。这是查询性能的巅峰状态。

创建索引的方法
-- 为单列创建索引
CREATE INDEX idx_emp_no ON employees (emp_no);
-- 为多列创建联合索引 (非常重要)
-- 顺序很关键！(first_name, last_name) 和 (last_name, first_name) 是两个不同的索引
CREATE INDEX idx_name ON employees (first_name, last_name);

查看索引
-- 语法
SHOW INDEX FROM table_name;
-- 
SHOW INDEX FROM employees;

删除索引:
-- 语法
DROP INDEX index_name ON table_name;
-- 示例
DROP INDEX idx_emp_no ON employees;


第四部分（深入版）：实战优化 employees 表
1.对索引进行计算，函数操作或类型转换
假设我们有个查询方式
-- 查询1999年入职的员工
SELECT id, emp_no, first_name, hire_date FROM employees WHERE YEAR(hire_date) = 1999;
通过explian，可以看到此时type为all，即全表扫描
然后对其hire_date即入职日期创建索引
create index inx_hire_date on employees (hire_date) 
再通过explain来查看索引扫描情况
explain SELECT id, emp_no, first_name, hire_date FROM employees WHERE YEAR(hire_date) = 1999;
可以发现还是全表扫描，扫描行数还是很大
这是因为我们对索引使用了类型转换，这会让索引失效，因此应该用
explain SELECT id, emp_no, first_name, hire_date FROM employees WHERE hire_date>'1999-01-01' and hire_date<'2000-01-01'
可以发现转为了range

案例三：索引覆盖
场景: 我们需要一个分页功能，按入职日期倒序显示员工的编号和姓名。
1. 普通索引查询
-- 查询最新入职的10名员工的编号和姓名
EXPLAIN SELECT emp_no, first_name, last_name FROM employees ORDER BY hire_date DESC LIMIT 10;
这种情况我们虽然对hire_date使用了索引，但是因为emp_no等字段我们仍需要回表查询，如果分页大，成本会非常高
2.覆盖索引优化
EXPLAIN SELECT emp_no, first_name, last_name FROM employees ORDER BY hire_date DESC LIMIT 10;
3.再次分析
EXPLAIN SELECT emp_no, first_name, last_name FROM employees ORDER BY hire_date DESC LIMIT 10;
我们可以看到此时extra里using index，表示完全不需要回表，全部都能从索引中获取

案例四：模糊查询陷阱
创建性命索引
CREATE INDEX idx_first_name ON employees (first_name);
-- 错误的使用方式：前缀模糊查询
EXPLAIN SELECT id, emp_no, first_name FROM employees WHERE first_name LIKE '%son';
2.使用explain
可以发现type是index，也就是索引查询，这个是因为mysql发现有索引时，会判断是使用索引还是全表查询的io消耗最少，因而使用了索引
3.原则：模糊查询必须让通配符不出现在开头，即不使用前缀模糊查询
EXPLAIN SELECT id, emp_no, first_name FROM employees WHERE first_name LIKE 'son%';
4.修改后的type为range，是范围查询，更好